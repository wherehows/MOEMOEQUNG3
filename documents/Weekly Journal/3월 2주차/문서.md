---
date: '2023-03-11'
title: '3월 2주차'
subTitle: '3월 2주차'
grandParent: ''
parent: 'Weekly Journal'
slug: '/weekly-journal/2023-03-11'
---

## 📌 axios와 react-query의 캐시 동작

bfcache 이론에 근거하면 뒤로가기 했을 때 데이터 요청이 발생하면 안된다. 하지만 현재 프로젝트는 뒤로가기 했을 때 데이터 요청이 발생한다. 팀장님께서 일전에 axios가 무조건 데이터를 요청하도록 설정해놨는데 혹시 이게 문제가 되는게 아닌지 확인해 봐달라고 하셨다. bfcache가 애초에 동작하지 않고 있어서 이러한 추론은 타당하기 어려워보였지만, axios의 캐시 설정과 react-query의 캐시 설정에 따라서 요청이 어떻게 처리되는지 궁금해서 테스트해봤다.

1. axios 및 react-query 모두 캐시를 설정하지 않으면 당연하게도 무조건적인 네트워크 요청이 발생한다.
2. axios 캐시 설정을 제거하고, react-query 캐시 옵션을 설정하면 캐시된 데이터에 한해서는 네트워크 요청 탭에 요청 항목이 보여지지 않는다.
3. react-query 캐시 설정을 제거하고, axios 캐시 옵션을 설정하면 캐시된 데이터에 한해서는 네트워크 요청 탭에 요청 항목이 보여지지만 disk cache로부터 반환된다.
4. axios 및 react-query 모두 캐시를 설정하면 캐시된 데이터에 한해서는 네트워크 요청 탭에 요청 항목이 보여지지 않는다.

react-query에서 캐싱을 설정하지 않으면 axios에서 설정해놓은 캐싱 결과가 동작하는 것 같다. 별개로 disk cache 뿐만 아니라 memory cache도 존재하는데, [둘의 차이](https://stackoverflow.com/questions/44596937/chrome-memory-cache-vs-disk-cache)는 disk cache는 데이터가 하드 드라이브에 저장되고 탭을 닫아도 데이터가 사라지지 않는 비휘발성 공간인 반면에 memory cache는 데이터가 ram에 저장되고 탭을 닫으면 사라지는 휘발성 데이터라고한다.

## 📌 usePrevious에 관한 이해

작업을 하면서 아래 코드의 동작이 잘 이해가 안갔다.

![](./usePrevious.png)
[코드 출처](https://codesandbox.io/s/pwnl6v7z6m)

App 컴포넌트 내의 useEffect 내부에서 count와 prevCount를 비교하면 prevCount가 항상 이전값을 보여준다. 대부분의 사람들의 경우 너무나 당연하게 이해할 수 있었을지 모르겠지만, 불행하게도 나는 아니었다. 내가 생각한 것은 다음과 같다. useEffect는 렌더링이 된 후에 실행된다. 그러므로 ref.current가 이후의 값으로 바뀌는 것도 렌더링이 된 후이다. 더불어서 App 컴포넌트 내의 useEffect 내의 prevCount는 이미 값이 바뀌어 있으므로 log에서 count와 prevCount가 같은 값을 가져야한다. 하지만 그렇지 않다.

답은 너무나 간단하게도 다음 문에 있다.

```javascript
const prevCount = usePrevious(count);
```

그러니까 이전 값을 prevCount라는 변수에 저장하고, ref라는 참조값에 접근하지 않기 때문에 항상 이전값을 보여줄 수 있는 것이다.

