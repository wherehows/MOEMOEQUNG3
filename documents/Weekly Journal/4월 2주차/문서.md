---
date: '2023-04-08'
title: '4월 2주차'
subTitle: '4월 2주차'
grandParent: ''
parent: 'Weekly Journal'
slug: '/weekly-journal/2023-04-08'
---

## 📌 메타프로그래밍이란

Proxy와 Reflect에 대한 공부를 하던 도중 메타 프로그래밍이라는 단어가 등장하는데 이해가 안돼서 정리했다.

메타프로그래밍 정의에 앞서서, 메타프로그래밍은 언어 특성이 아니며 스탠다드도 존재하지 않기 때문에 사용하는 언어와 사람에 따라서 다르게 해석될 수 있음을 전제한다. (여러 문서를 읽어본바 정의가 조금씩은 다르나 큰 틀은 벗어나지 않는 것 같다. 🧐) 그러므로 메타프로그래밍 정의에 관해서 애써 기억할 필요가 없고, 다만 컨셉에 대해서는 이해해 놓을 필요가 있다.

[위키피디아](https://en.wikipedia.org/wiki/Metaprogramming)에서는 메타프로그래밍을 다음과 같이 정의한다. 

>메타프로그래밍은 프로그래밍 기술로, 다른 프로그램을 데이터로 취급하여 분석, 생성, 변형등의 조작을 하는 어떤 프로그램을 작성하는 것

대부분의 문서가 이 정의로 시작을 하는데, 이 정의만을 놓고보면 다음 코드가 왜 메타프로그래밍인지 이해가 잘안간다.

```typescript
function coerce(value) {
  if(typeof value === 'string') {
    return parseInt(value);
  } else if(typeof value === 'boolean') {
    return value === true ? 1: 0;
  } else if(value instanceof Employee) {
    return value.salary;
  } else {
    return value;
  }
}

console.log(1 + coerce(true)); // 2 
console.log(1 + coerce(3)); // 4
console.log(1 + coerce('20 items')); // 21
console.log(1 + coerce(new Employee('Ross', 100))); // 101
```

앞선 정의를 바탕으로 해석하면 위 코드에서 어떤 프로그램은 무엇이고 다른 프로그램은 무엇일까? 이해를 돕기 위해서 메타프로그래밍을 다시 정의하면 다음과 같이 정의할 수 있다.

> 메타프로그래밍은 프로그래밍 기술로, 다른 코드를 데이터로 취급하여 분석, 생성, 변형등의 조작을 하는 코드를 작성하는 것을 의미한다. 이는 런타임에 기존 코드가 동작에 맞게 자기 자신을 변형하는 것을 포함한다. 이를 위해서는 기존 코드를 분석하고 변형하는 과정이 필요한데, 자바스크립트에서는 Proxy나 Reflect를 이용할 수 있다.

이러한 정의를 바탕으로 앞선 코드를 이해해보면 "corece라는 함수가 들어오는 코드(value, 런타임에는 유저가 입력한 무언가가 될수 있을 것 같다)에 따라서 메타프로그래밍을 구현하는 typeof를 통해서 알맞은 동작을 수행하고, 기존 코드(log되는 결과)가 수정될 수 있구나"정도로 해석할 수 있을 것 같다.

정의는 여기까지하고 메타프로그래밍이 무엇인지에 대해서 조금 더 깊게 들어가보자. 메타프로그래밍은 크게 다음 두가지 능력을 갖고 있다.

- 프로그램 코드를 생성하는 능력(Code Generation)
- 프로그램이 자기 자신을 조작하거나 다른 프로그램을 조작할 수 있는 능력(Reflection 혹은 Reflective Programming)

그리고 Reflection은 다시 다음 세가지로 분류할 수 있다.

- introspection(분석)
- intercession(중재)
- self-modification(자기 수정)

코드를 생성하는 코드는 eval을 예로들수 있다. string으로 작성된 자바스크립트 코드는 런타임에 자바스크립트 코드가 생성되어 실행된다.

introspection은 프로그램이 자신의 구조를 분석하는 것이다.  ES6 이전에는 `typeof`, `instanceof`, `Object.*` 등을 이용할 수 있고, ES6 이후부터는 introspection을 위한 `Reflect` API가 도입되었다. 코드로보면 다음과 같다.

```typescript
채워야행
```

보이듯 introspection을 통해서 적절한 동작을 수행하고 있다.

intercession은 기본 동작을 재정의하는 것이다. 원본(target)을 수정하지 말아야 한다는 전제가 존재한다. ES6부터 Proxy를 이용해서 가능하며, ES5에서는 getter와 setter를 이용해서 비슷하게 구현 가능하지만, 원본이 수정된다는 점에서 intercession으로 보기 어렵다.

```typescript
var target = { name: 'Ross', salary: 200 };

var targetWithProxy = new Proxy(target, {
  get: function(target, prop) {
    return prop === 'salary' ? target[prop] + 100 : null;
  }
})

console.log('proxy:', targetWithProxy.salary); // proxy: 300
console.log('target:', target.salary); // target: 200
```

Proxy는 두번째 인자에 정의된 핸들러 객체를 전달할 수 있다. 핸들러 객체 내부에는 동작을 가로채는 get과 set과 같은 trap이 정의될 수 있다. targetWithProxy.salary에 접근할 때, trap 함수인 get 함수가 읽기 동작을 가로채므로, 300이라는 결과가 나오게된다.

self-modification은 프로그램이 자기 자신을 수정할 수 있는 것이다. intercession과는 다르게 원본이 변경된다.

```typescript
var blog = {
    name: 'freeCodeCamp',
    modifySelf: function(key, value) { blog[key] = value }
}

blog.modifySelf('author', 'Tapas');
```

여기까지 메타프로그래밍에 대해서 알아보았다. 다시한번 언급하지만 메타프로그래밍은 "프로그래밍 언어 특징"이나 "표준화된 것"으로 묘사될 수 없고, "수용력(Capacity)"에 가깝다. Go와 같은 몇몇 프로그래밍 언어는 메타프로그래밍을 완전히 지원하지 않고 일부만 지원한다.

## 📚 참고문헌

[A brief introduction to Metaprogramming in JavaScript](https://medium.com/jspoint/a-brief-introduction-to-metaprogramming-in-javascript-88d13ed407b5)

[Metaprograaming with Proxies](https://exploringjs.com/deep-js/ch_proxies.html)

[What is Metaprogramming in JavaScript? In English, please](https://www.freecodecamp.org/news/what-is-metaprogramming-in-javascript-in-english-please/)

[Comprehensive Guide To Metaprogramming in Javascript](https://isamatov.com/metaprogramming-in-javascript/)

[Exploring Metaprogramming, Proxying And Reflection In JavaScript](https://blog.openreplay.com/exploring-metaprogramming-proxying-and-reflection-in-javascript/)

---
