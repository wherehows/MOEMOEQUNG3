---
date: '2022-08-27'
title: '8월 4주차'
subTitle: '8월 4주차'
parent: 'Weekly Journal'
slug: '/weekly-journal/2022-08-27'
---

## 📌 요소의 프로퍼티 가져오기

요소의 높이(clientHeight)나 스크롤 내 위치(offsetTop)에 접근해야만 하는 로직이 존재했다. 리액트에서 useRef로 DOM 요소의 높이 정보에 접근하기 전에, current의 초기값으로 null이 할당되기 때문에 null에 대한 처리도 무조건 해주어야했다. 본인은 non null로 처리를 했는데, 팀장님께서 가급적 javascript로 처리를 해라고 피드백주셨다. (개인적으로 이럴때 만큼은 non null을 써도 되지 않나 싶은...)

그러면

```javascript
useEffect(() => {
    const elementHeight = elementRef.current!.clientHeight;
    setElementHeight(elementHeight);
}, [])
```

이랬던 코드가

```javascript
useEffect(() => {
  const elementHeight = elementRef.current?.clientHeight

  if (elementHeight && elementHeight !== 0) {
    setElementHeight(elementHeight)
  }
}, [])
```

높이값 존재 여부를 확인하는 조건문이 추가되면서 이렇게 길어지게 된다.

길어보이지 않을 수 있지만, 본인이 하고있는 프로젝트에서는 요소 5개의 높이값 및 스크롤 내 위치값을 구해야하고 계산하는 로직도 들어가기 때문에, 아래와 같이 코드가 매우매우 길어지게된다.

```javascript
useEffect(() => {
   const profileHeight = profileRef.current?.clientHeight;
   const topAreaHeight = topAreaRef.current?.clientHeight;
   const commentWriteHeight = commentWriteHeight.current?.clientHeight;

   const profilePosition = profilePosition.current?.offsetTop;
   const commentPosition = commentPosition.current?.offsetTop;

    let visibility = null;

   if(높이값 존재하는지 확인) {
        visibility = profilePosition + commentPosition - 5;
   }

   if(높이값 존재하는지 확인) {
        높이값 상태를 업데이트하는 setter 함수 호출
   }
   ...
}, [])
```

코드 가독성 개선을 위해 소괄호 내부의 조건문을 isNil로 바꿔주었다.

```javascript
useEffect(() => {
  const elementHeight = elementRef.current?.clientHeight

  if (helpers.isNil(elementHeight)) {
    setElementHeight(elementHeight)
  }
}, [])
```

하지만 타입이 정제되지 않기 때문에 if문 내부에서 elementHeight에 대한 타입이 정제되지 않는다. 그렇기 때문에 타입 단언을 별도로 해야하는 불편함이 있다.

어떻게 하면 이를 개선할 수 있을까 하다가 isNil에 사용자 정의 타입 가드를 추가했다.

```javascript
const isNil = <T>(param: unknown): param is T => param !== undefined && param !== null;
```

고민을 하다가 요소의 높이값을 가져올 때 helper 함수를 거치게 함으로써 사용자 정의 타입 가드가 바로 동작하도록 만들었다.

```javascript
const helper = (param: any, type?: any): param is (typeof type extends undefined ? number : typeof type) => param !== undefined && param !== null;
```

---

## 📌 곪아 터져버린 타입 폴더

페지별로 타입을 관리하며 개발해왔다. 타입을 선언하면서도 언젠가 타입 충돌이 일어나지 않을까 예상은 했었는데 오늘 터져버렸다. 동료가 개발하면서 선언한 타입이 내가 선언한 타입과 충돌이 일어난 것이다. (덕분에 squiggly lines에 대해서 눈으로만 확인해오고 터미널의 problems 탭은 확인하지 않았는데, 이제부터 확인하게 될것 같다.)

어떻게 하면 이러한 상황을 예방할 수 있었을까 생각해보면, 100%는 예뱡하는 것은 불가능하지 않나 싶다. 물론 새로운 타입을 선언할 때마다, 왠지 충돌이 날것 같은 이름을 지을 때마다 한번쯤 확인할 수는 있지만 명확한 기준도 없고 너무 피곤한 일인 것 같다.

다만 조금이라도 이러한 상황에 처하지 않기 위해서 FE 팀장님께 타입 폴더를 다음 세가지로 분류하는게 어떨까 하고 제안드렸다.

1. libraries
2. pages
3. apis

그리고 어느 폴더에도 속하지 않는 common.d.ts를 두는 것이다.

libraries 폴더의 경우, 현재 족히 5개 이상의 페이지에서 사용중인 구글 맵 라이브러리 혹은 mui 관련 타입을 선언하고, pages의 경우 클라이언트 상태 혹은 받아온 api에서 재가공된 타입들을 선언한다. 마지막으로 apis는 서버에서 내려주는 순수한 api 관련 타입들을 저장한다.

이렇게 구분한다고해서 타입 충돌을 100% 막을 수있는 것은 아니지만, 빈도는 낮출 수 있으리라 생각했고, FE 팀장님 역시도 흔쾌히 받아들여 주셨다.

---

## 📌 Property does not exist on type 'never'

최근 작업을 하면서 위 에러를 자주 마주쳤다. 기술 부재로 인해서 매번 타입 단언을 통해서 해결하여 넘어갔는데, 왜 특정 변수를 never 타입으로 인식하는지 궁금해서 찾아보았다.

우선 위 에러가 발생하는 코드는 두가지가 존재하는데, 그중 하나를 [stackoverflow](https://stackoverflow.com/questions/44147937/property-does-not-exist-on-type-never)에서 가져왔다.

```javascript
interface Foo {
  a: 1;
}

let instance: Foo | null = null

const mutate = () =>
  (instance = {
    a: 1,
  })

if (!instance) {
  console.log(null)
} else {
  console.log(instance.a) // 🔥 에러 발생 지점
}
```

첫 번째 예시는 왜 never 타입에 property가 존재하지 않는다고 표시하고 있을까? 타입스크립트 핸드북과 앞서 언급한 stackoverflow 답변들에서 해답을 얻을 수 있었다.

> **The never type represents th e type of values that never occur.** For instance, never is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns. **Variables also acquire the type never when narrowed by any type guards that can never be true.**

bold처리된 내용을 해석해보면, never타입은 절대로 존재할 수 없는 값에 대한 타입이다. (...) 사실일 수 없는 타입 가드(else 문은 절대로 실행되지 않는다.)에 의해서 타입이 좁혀진 경우, 변수는 never타입을 갖게 된다.

그렇기 때문에 아래와 같이 옵셔널 체이닝을 쓸때도 동일한 에러가 발생한다.

```javascript
const instance = {
  key: 'foo',
}

console.log(instance.key?.bar) // 🔥 에러 발생 지점
```

